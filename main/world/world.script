math.randomseed(os.time())
math.random(); math.random(); math.random()

local ELD = require("main.elderizer")
local STATS = require("main.Actors.actorStats")
local P = require("main.player")
local houses = {}
local dwellers = {}
local heroes = {}
local dwellersList = {"spider", "goblin"}

local activeLevel = nil
local gold = {}; for x = 1, 7 do gold[x] = 0 end

local currentAction = {action = "call", target = "spider"}

local function addCottage()
	local posX = 0
	local spread = 5
	for x = 1, spread do
		posX = posX + math.random(50, 600)
	end
	posX = posX / spread
	local posY = (math.random(879, 889))
	local posZ = -(((posY - 869) / 100) - 0.1)
	table.insert(houses, factory.create("#spawn_house", vmath.vector3(posX, posY, posZ)))
end

local hero = {}

function hero.spawn(level)
	table.insert(heroes, factory.create("#spawn_hero", vmath.vector3(-10, 880, 0.65), nil, STATS.hero))
end

function init(self)
	msg.post(".", "acquire_input_focus")
	msg.post("@render:", "use_fixed_fit_projection")
	P.name = ELD.elderize("Klear")
	print(P.name)
	for x = 1, 20 do
		addCottage()
	end
	timer.delay(1, true, function() P.essence = P.essence + P.rechargeRate; label.set_text("#essence", P.essence) end)
	-- create caves
	for y = 0, 6 do
		factory.create("#caveSpawner", vmath.vector3(50, 800 - y * 100, 0.6), nil, {type = 1})
		factory.create("#caveSpawner", vmath.vector3(590, 800 - y * 100, 0.6), nil, {type = 3})
		for x = 0, 3 do
			factory.create("#caveSpawner", vmath.vector3(155 + x * 110, 800 - y * 100, 0.6), nil)
		end
	end
end

local function getLevel(y)
	local level
	if y > 850 then level = 0
	elseif y > 750 then level = 1
	elseif y > 650 then level = 2
	elseif y > 550 then level = 3
	elseif y > 450 then level = 4
	elseif y > 350 then level = 5
	elseif y > 250 then level = 6
	elseif y > 150 then level = 7
	end
	return level
end

local channel = {}
local dweller = {}

function dweller.count(level, type)
	local count = 0
	for key, val in ipairs(dwellers) do
		if val.type == type and val.level == level then
			count = count + 1
		end
	end
	return count
end

function dweller.most(level)
	local bestCount = 0
	local best
	for key, val in ipairs(dwellersList) do
		local count = dweller.count(level, val)
		if count > bestCount then
			best = val; bestCount = count
		end
	end
	return best
end

function dweller.empowerable(level)
	local bestCount = 0
	local best
	for key, val in ipairs(dwellersList) do
		local count = dweller.count(level, val)
		if count > bestCount and dweller.count(level, val.."_boss") == 0 then
			best = val; bestCount = count
		end
	end
	return best
end

function dweller.closest(type, level)
	local closest
	local distance = 1/0
	for key, val in ipairs(dwellers) do
		if val.level == level and val.type == type and math.abs(go.get_position(val.go).x - go.get_position("cursorEffects").x) < distance then
			closest = key; distance = math.abs(go.get_position(val.go).x - go.get_position("cursorEffects").x)
		end
	end
	return closest
end

function channel.done()
	if currentAction.action == "call" then
		table.insert(dwellers, {go = factory.create("#spawn_"..currentAction.target, vmath.vector3(20, 880 - activeLevel * 100, 0.65), nil, STATS[currentAction.target]), type = currentAction.target, level = activeLevel})
		P.essence = P.essence - STATS[currentAction.target].callCost
		label.set_text("#essence", P.essence)
	elseif currentAction.action == "empower" then
		local target = dweller.empowerable(activeLevel)
		if target then
			local newBoss = dweller.closest(target, activeLevel)
			local newGO = {go = factory.create("#spawn_"..target.."_boss", go.get_position(dwellers[newBoss].go), nil, STATS[target.."_boss"]), type = target.."_boss", level = activeLevel}
			go.delete(dwellers[newBoss].go, true)
			dwellers[newBoss] = newGO
		end
	end
end


function on_input(self, action_id, action)
	if action_id == hash("touch") and currentAction.action then
		local level = getLevel(action.y)
		if action.pressed then
			activeLevel = level
			particlefx.play("cursorEffects#"..currentAction.action)
			if level then
				particlefx.play("fx#"..currentAction.action.."AreaCave"..level)
				if currentAction.action == "call" then
					channel.timer = timer.delay(STATS[currentAction.target].callTime, true, channel.done)				
				elseif currentAction.action == "empower" then
					local target = dweller.empowerable(level)
					if target then 
						channel.timer = timer.delay(STATS[target].empowerTime, true, channel.done)
					end
				end
			end
		elseif action.released then
			particlefx.stop("cursorEffects#"..currentAction.action)
			if activeLevel then
				particlefx.stop("fx#"..currentAction.action.."AreaCave"..activeLevel)
				if channel.timer then timer.cancel(channel.timer) end
				activeLevel = nil
			end
		else
			if activeLevel ~= level then
				if activeLevel then
					particlefx.stop("fx#"..currentAction.action.."AreaCave"..activeLevel)
					if channel.timer then timer.cancel(channel.timer) end
				end
				activeLevel = level
				if level then
					particlefx.play("fx#"..currentAction.action.."AreaCave"..level)
					if currentAction.action == "call" then
						channel.timer = timer.delay(STATS[currentAction.target].callTime, true, channel.done)				
					elseif currentAction.action == "empower" then
						local target = dweller.empowerable(level)
						if target then 
							channel.timer = timer.delay(STATS[target].empowerTime, true, channel.done)
						end
					end
				end
			end
		end
		go.set_position(vmath.vector3(action.x, action.y, 1), "cursorEffects")
	elseif action_id == hash("summon") and action.pressed then
		hero.spawn(1)
	end
end

function on_message(self, message_id, message, sender)
	if message_id == hash("setAction") then
		particlefx.stop("cursorEffects#"..currentAction.action)
		currentAction = {action = message.action, target = message.target}
	elseif message_id == hash("removeDweller") then
		for key, val in ipairs(dwellers) do
			if val.go == sender.path then
				table.remove(dwellers, key)
				break
			end
		end
	elseif message_id == hash("spawn") then
		local type
		if message.type == hash("spider_boss") then type = "spider" end
		table.insert(dwellers, {go = factory.create("#spawn_"..type, vmath.vector3(message.pos, 880 - message.level * 100, 0.65), nil, STATS[type]), type = type, level = level})
		if message.guard then msg.post(dwellers[#dwellers].go, "orders", {orders = hash("guard")}) end
	elseif message_id == hash("coinDrop") then
		gold[message.level] = gold[message.level] + message.gold
	end
end