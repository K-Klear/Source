go.property("health", 1)
go.property("attack", 1)
go.property("attack_speed", 1)
go.property("speed", 1)
go.property("alive", true)
go.property("orders", hash("patrol"))
go.property("type", hash("hero"))

local FADE_DELAY = 10
local FADE_TIME = 3

local idle
local exitDown = {40, 620, 40, 620, 40, 620, 40}
exitDown[0] = 620
local exitUp = {620, 40, 620, 40, 620, 40, 620}
exitUp[0] = -10

local function walk(self, X)
	local currentX = go.get_position().x
	sprite.play_flipbook("#sprite", "walk")
	sprite.set_hflip("#sprite", X < currentX)
	go.animate(go.get_id(), "position.x", go.PLAYBACK_ONCE_FORWARD, X, go.EASING_LINEAR, math.abs(currentX - X) / self.speed, 0, idle)
	self.action = hash("walk")
end

function idle(self)
	if self.orders == hash("patrol") then
		if go.get_position().x > 320 then
			walk(self, 40)
		else
			walk(self, 620)
		end
	elseif self.orders == hash("explore") then
		local currentX = go.get_position().x
		if currentX == exitDown[self.level] then
			self.level = self.level + 1
			local pos = go.get_position()
			pos.y = pos.y - 100
			go.set_position(pos)
			walk(self, exitDown[self.level])
		else
			walk(self, exitDown[self.level])
		end
	elseif self.orders == hash("flee") then
		local currentX = go.get_position().x
		if currentX == exitUp[self.level] then
			self.level = self.level - 1
			local pos = go.get_position()
			pos.y = pos.y + 100
			go.set_position(pos)
			walk(self, exitUp[self.level])
			print(self.health)
		else
			walk(self, exitUp[self.level])
		end
	end
end

local function attack(self)
	if self.alive and #self.target > 0 then
		sprite.play_flipbook("#sprite", "attack")
		msg.post(self.target[1], hash("take_damage"), {damage = self.attack})
		timer.delay(self.attack_speed, false, attack)
	elseif self.alive and #self.target == 0 then
		idle(self)
	end
end

local function fight(self)
	go.cancel_animations(go.get_id(), "position")
	if go.get_position(self.target[1]).x > go.get_position().x then
		sprite.set_hflip("#sprite", false)
	else
		sprite.set_hflip("#sprite", true)
	end
	self.action = hash("fight")
	attack(self)
end

local function die(self)
	self.alive = false
	go.set_position(vmath.vector3(go.get_position().x, go.get_position().y, 0.4))
	go.cancel_animations(go.get_id(), "position")
	sprite.play_flipbook("#sprite", "dead")
	msg.post("#collisionobject", "disable")
	msg.post("/world", "removeDweller")
	timer.delay(FADE_DELAY, false, function(self) go.animate("#sprite", "tint.w", go.PLAYBACK_ONCE_FORWARD, 0, go.EASING_LINEAR, FADE_TIME, 0, function(self) go.delete(go.get_id()) end) end)
end

local function getLevel(y)
	local level
	if y > 850 then level = 0
	elseif y > 750 then level = 1
	elseif y > 650 then level = 2
	elseif y > 550 then level = 3
	elseif y > 450 then level = 4
	elseif y > 350 then level = 5
	elseif y > 250 then level = 6
	elseif y > 150 then level = 7
	end
	return level
end

function init(self)
	self.level = getLevel(go.get_position(go.get_id()).y)
	self.kills = {}
	self.target = {}
	if self.type == hash("hero") then
		self.bravery = (math.random() + math.random()) / 4
	else
		self.bravery = 0
	end
	self.maxHealth = self.health
	idle(self)
end

function on_message(self, message_id, message, sender)
	if message_id == hash("trigger_response") then
		if (message.own_group == hash("hero_range") and message.other_group == hash("dweller_body")) or (message.own_group == hash("dweller_range") and message.other_group == hash("hero_body")) then
			if message.enter then
				table.insert(self.target, message.other_id)
				if self.action ~= hash("fight") then fight(self) end
			else
				for key, val in ipairs(self.target) do
					if val == message.other_id then
						table.remove(self.target, key)
						break
					end
				end
			end
		end
	elseif message_id == hash("take_damage") then
		self.health = self.health - message.damage
		if self.health < 1 then
			die(self)
			msg.post(sender, "target_dead", {type = self.type})
		else
			if self.maxHealth * self.bravery > self.health then
				self.orders = hash("flee")
				self.target = {}
				idle(self)
			end
		end
	elseif message_id == hash("target_dead") then
		for key, val in ipairs(self.target) do
			if val == sender.path then
				table.remove(self.target, key)
				break
			end
		end
		self.kills[message.type] = self.kills[message.type] or 0
		self.kills[message.type] = self.kills[message.type] + 1 
	end
end